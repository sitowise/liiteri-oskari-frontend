! function(e, n) {
    "object" == typeof exports ? module.exports = n() : "function" == typeof define && define.amd ? define([], function() {
        return e.Channel = n()
    }) : e.Channel = n()
}(this, function() {
    "use strict";
    var e = function() {
        function e(e, n, t, o) {
            function i(n) {
                for (var t = 0; t < n.length; t++)
                    if (n[t].win === e) return !0;
                return !1
            }
            var s = !1;
            if ("*" === n) {
                for (var a in r)
                    if (r.hasOwnProperty(a) && "*" !== a && "object" == typeof r[a][t] && (s = i(r[a][t]))) break
            } else r["*"] && r["*"][t] && (s = i(r["*"][t])), !s && r[n] && r[n][t] && (s = i(r[n][t]));
            if (s) throw "A channel is already bound to the same window which overlaps with origin '" + n + "' and has scope '" + t + "'";
            "object" != typeof r[n] && (r[n] = {}), "object" != typeof r[n][t] && (r[n][t] = []), r[n][t].push({
                win: e,
                handler: o
            })
        }

        function n(e, n, t) {
            for (var o = r[n][t], i = 0; i < o.length; i++) o[i].win === e && o.splice(i, 1);
            0 === r[n][t].length && delete r[n][t]
        }

        function t(e) {
            return Array.isArray ? Array.isArray(e) : -1 != e.constructor.toString().indexOf("Array")
        }
        var o = Math.floor(1000001 * Math.random()),
            r = {},
            i = {},
            s = function(e) {
                try {
                    var n = JSON.parse(e.data);
                    if ("object" != typeof n || null === n) throw "malformed"
                } catch (e) {
                    return
                }
                var t, o, s, a = e.source,
                    c = e.origin;
                if ("string" == typeof n.method) {
                    var l = n.method.split("::");
                    2 == l.length ? (t = l[0], s = l[1]) : s = n.method
                }
                if ("undefined" != typeof n.id && (o = n.id), "string" == typeof s) {
                    var f = !1;
                    if (r[c] && r[c][t])
                        for (var d = 0; d < r[c][t].length; d++)
                            if (r[c][t][d].win === a) {
                                r[c][t][d].handler(c, s, n), f = !0;
                                break
                            }
                    if (!f && r["*"] && r["*"][t])
                        for (var d = 0; d < r["*"][t].length; d++)
                            if (r["*"][t][d].win === a) {
                                r["*"][t][d].handler(c, s, n);
                                break
                            }
                } else "undefined" != typeof o && i[o] && i[o](c, s, n)
            };
        return window.addEventListener ? window.addEventListener("message", s, !1) : window.attachEvent && window.attachEvent("onmessage", s), {
            build: function(r) {
                var s = function(e) {
                    if (r.debugOutput && window.console && window.console.log) {
                        try {
                            "string" != typeof e && (e = JSON.stringify(e))
                        } catch (n) {}
                        window.console.log("[" + l + "] " + e)
                    }
                };
                if (!window.postMessage) throw "jschannel cannot run this browser, no postMessage";
                if (!window.JSON || !window.JSON.stringify || !window.JSON.parse) throw "jschannel cannot run this browser, no JSON parsing/serialization";
                if ("object" != typeof r) throw "Channel build invoked without a proper object argument";
                if (!r.window || !r.window.postMessage) throw "Channel.build() called without a valid window argument";
                if (window === r.window) throw "target window is same as present window -- not allowed";
                var a = !1;
                if ("string" == typeof r.origin) {
                    var c;
                    "*" === r.origin ? a = !0 : null !== (c = r.origin.match(/^https?:\/\/(?:[-a-zA-Z0-9_\.])+(?::\d+)?/)) && (r.origin = c[0].toLowerCase(), a = !0)
                }
                if (!a) throw "Channel.build() called with an invalid origin";
                if ("undefined" != typeof r.scope) {
                    if ("string" != typeof r.scope) throw "scope, when specified, must be a string";
                    if (r.scope.split("::").length > 1) throw "scope may not contain double colons: '::'"
                } else r.scope = "__default";
                var l = function() {
                        for (var e = "", n = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", t = 0; 5 > t; t++) e += n.charAt(Math.floor(Math.random() * n.length));
                        return e
                    }(),
                    f = {},
                    d = {},
                    u = {},
                    h = !1,
                    p = [],
                    g = [],
                    w = function(e, n, t) {
                        var o = !1,
                            r = !1;
                        return {
                            origin: n,
                            invoke: function(n, o) {
                                if (!u[e]) throw "attempting to invoke a callback of a nonexistent transaction: " + e;
                                for (var r = !1, i = 0; i < t.length; i++)
                                    if (n === t[i]) {
                                        r = !0;
                                        break
                                    }
                                if (!r) throw "request supports no such callback '" + n + "'";
                                v({
                                    id: e,
                                    callback: n,
                                    params: o
                                })
                            },
                            error: function(n, t) {
                                if (r = !0, !u[e]) throw "error called for nonexistent message: " + e;
                                delete u[e], v({
                                    id: e,
                                    error: n,
                                    message: t
                                })
                            },
                            complete: function(n) {
                                if (r = !0, !u[e]) throw "complete called for nonexistent message: " + e;
                                delete u[e], v({
                                    id: e,
                                    result: n
                                })
                            },
                            delayReturn: function(e) {
                                return "boolean" == typeof e && (o = e === !0), o
                            },
                            completed: function() {
                                return r
                            }
                        }
                    },
                    m = function(e, n, t) {
                        return window.setTimeout(function() {
                            if (d[e]) {
                                var o = "timeout (" + n + "ms) exceeded on method '" + t + "'";
                                d[e].error && d[e].error("timeout_error", o), delete d[e], delete i[e]
                            }
                        }, n)
                    },
                    y = function(e, n, o) {
                        if ("function" == typeof r.gotMessageObserver) try {
                            r.gotMessageObserver(e, o)
                        } catch (a) {
                            s("gotMessageObserver() raised an exception: " + a.toString())
                        }
                        if (o.id && n) {
                            u[o.id] = {};
                            var c = w(o.id, e, o.callbacks ? o.callbacks : []);
                            if (f[n]) try {
                                if (o.callbacks && t(o.callbacks) && o.callbacks.length > 0)
                                    for (var l = 0; l < o.callbacks.length; l++) {
                                        for (var h = o.callbacks[l], p = o.params, g = h.split("/"), m = 0; m < g.length - 1; m++) {
                                            var y = g[m];
                                            "object" != typeof p[y] && (p[y] = {}), p = p[y]
                                        }
                                        p[g[g.length - 1]] = function() {
                                            var e = h;
                                            return function(n) {
                                                return c.invoke(e, n)
                                            }
                                        }()
                                    }
                                var b = f[n](c, o.params);
                                c.delayReturn() || c.completed() || c.complete(b)
                            } catch (a) {
                                var v = "runtime_error",
                                    k = null;
                                if ("string" == typeof a ? k = a : "object" == typeof a && (a instanceof Error ? (v = a.constructor.name, k = a.message) : a && t(a) && 2 == a.length ? (v = a[0], k = a[1]) : "string" == typeof a.error && (v = a.error, a.message ? "string" == typeof a.message ? k = a.message : a = a.message : k = "")), null === k) try {
                                    k = JSON.stringify(a), "undefined" == typeof k && (k = a.toString())
                                } catch (E) {
                                    k = a.toString()
                                }
                                c.error(v, k)
                            } else c.error("method_not_found", "No method '" + n + "' was (yet) bound by the provider")
                        } else o.id && o.callback ? d[o.id] && d[o.id].callbacks && d[o.id].callbacks[o.callback] ? d[o.id].callbacks[o.callback](o.params) : s("ignoring invalid callback, id:" + o.id + " (" + o.callback + ")") : o.id ? d[o.id] ? (o.error ? d[o.id].error && d[o.id].error(o.error, o.message) : void 0 !== o.result ? d[o.id].success(o.result) : d[o.id].success(), delete d[o.id], delete i[o.id]) : s("ignoring invalid response: " + o.id) : n && f[n] && f[n]({
                            origin: e
                        }, o.params)
                    };
                e(r.window, r.origin, r.scope, y);
                var b = function(e) {
                        return [r.scope, e].join("::")
                    },
                    v = function(e, n) {
                        if (!e) throw "postMessage called with null message";
                        if (n || h) {
                            if ("function" == typeof r.postMessageObserver) try {
                                r.postMessageObserver(r.origin, e)
                            } catch (t) {
                                s("postMessageObserver() raised an exception: " + t.toString())
                            }
                            s("post message: " + JSON.stringify(e) + " with origin " + r.origin), r.window.postMessage(JSON.stringify(e), r.origin)
                        } else s("queue message: " + JSON.stringify(e)), p.push(e)
                    },
                    k = function(e, n) {
                        if (s("ready msg received"), h && !r.reconnect) throw "received ready message while in ready state.";
                        h = !0, l.length < 6 && (l += "publish-request" === n.type ? "-R" : "-L"), s("ready msg accepted."), "publish-request" === n.type && _.notify({
                            method: "__ready",
                            params: {
                                type: "publish-reply",
                                publish: g
                            }
                        });
                        for (var t = 0; t < n.publish.length; t++) "bind" === n.publish[t].action ? E([n.publish[t].method], _.remote) : delete _.remote[n.publish[t].method];
                        for (r.reconnect || _.unbind("__ready", !0); p.length;) v(p.splice(0, 1)[0]);
                        g = [], "function" == typeof r.onReady && r.onReady(_)
                    },
                    E = function(e, n) {
                        e = [].concat(e);
                        for (var t, o = 0; o < e.length; o++) t = e[o].toString(), n[t] = function(e) {
                            return function(n, t, o) {
                                t ? _.call({
                                    method: e,
                                    params: n,
                                    success: t,
                                    error: o
                                }) : _.notify({
                                    method: e,
                                    params: n
                                })
                            }
                        }(t)
                    },
                    O = function(e, n) {
                        E([n], _.remote)
                    },
                    S = function(e, n) {
                        _.remote[n] && delete _.remote[n]
                    },
                    _ = {
                        remote: {},
                        unbind: function(e, n) {
                            if (f[e]) {
                                if (!delete f[e]) throw "can't delete method: " + e;
                                return r.publish && !n && (h ? _.notify({
                                    method: "__unbind",
                                    params: e
                                }) : g.push({
                                    action: "unbind",
                                    method: e
                                })), !0
                            }
                            return !1
                        },
                        bind: function(e, n, t) {
                            if (!e || "string" != typeof e) throw "'method' argument to bind must be string";
                            if (!n || "function" != typeof n) throw "callback missing from bind params";
                            if (f[e]) throw "method '" + e + "' is already bound!";
                            return f[e] = n, r.publish && !t && (h ? _.notify({
                                method: "__bind",
                                params: e
                            }) : g.push({
                                action: "bind",
                                method: e
                            })), this
                        },
                        call: function(e) {
                            if (!e) throw "missing arguments to call function";
                            if (!e.method || "string" != typeof e.method) throw "'method' argument to call must be string";
                            if (!e.success || "function" != typeof e.success) throw "'success' callback missing from call";
                            var n = {},
                                t = [],
                                r = [],
                                s = function(e, o) {
                                    if (r.indexOf(o) >= 0) throw "params cannot be a recursive data structure";
                                    if (o && r.push(o), "object" == typeof o)
                                        for (var i in o)
                                            if (o.hasOwnProperty(i)) {
                                                var a = e + (e.length ? "/" : "") + i;
                                                "function" == typeof o[i] ? (n[a] = o[i], t.push(a), delete o[i]) : "object" == typeof o[i] && s(a, o[i])
                                            }
                                };
                            s("", e.params);
                            var a = {
                                id: o,
                                method: b(e.method),
                                params: e.params
                            };
                            t.length && (a.callbacks = t), e.timeout && m(o, e.timeout, b(e.method)), d[o] = {
                                callbacks: n,
                                error: e.error,
                                success: e.success
                            }, i[o] = y, o++, v(a)
                        },
                        notify: function(e) {
                            if (!e) throw "missing arguments to notify function";
                            if (!e.method || "string" != typeof e.method) throw "'method' argument to notify must be string";
                            v({
                                method: b(e.method),
                                params: e.params
                            })
                        },
                        destroy: function() {
                            n(r.window, r.origin, r.scope), window.removeEventListener ? window.removeEventListener("message", y, !1) : window.detachEvent && window.detachEvent("onmessage", y), h = !1, f = {}, u = {}, d = {}, r.origin = null, p = [], s("channel destroyed"), l = ""
                        }
                    };
                return _.bind("__ready", k, !0), _.bind("__bind", O, !0), _.bind("__unbind", S, !0), r.remote && E(r.remote, _.remote), setTimeout(function() {
                    l.length > 0 && v({
                        method: b("__ready"),
                        params: {
                            type: "publish-request",
                            publish: g
                        }
                    }, !0)
                }, 0), _
            }
        }
    }();
    return e
}),
function(e, n) {
    "function" == typeof define && define.amd ? define(["jschannel"], n) : "object" == typeof module && module.exports ? module.exports = n(require("jschannel")) : e.OskariRPC = n(e.Channel)
}(this, function(e) {
    "use strict";
    var n = "2.0.4";
    return {
        VERSION: n,
        connect: function(t, o) {
            if (null === e || void 0 === e) throw new Error("JSChannel not found.");
            if (null === t || void 0 === t) throw new TypeError("Missing target element.");
            if (!t.contentWindow) throw new TypeError("Target is missing contentWindow.");
            if (null === o || void 0 === o) throw new TypeError("Missing origin.");
            if (0 !== o.indexOf("http")) throw new TypeError("Invalid origin: " + o + ".");
            var r = !1,
                i = [],
                s = !1,
                a = {};
            a.enableDebug = function(e) {
                s = !!e
            }, a.log = function() {
                window.console && window.console.log && window.console.log.apply(window.console, arguments)
            };
            var c = function() {
                throw a.log("Error", arguments), new Error("RPC call failed!")
            };
            a.isReady = function() {
                return r
            }, a.onReady = function(e) {
                "function" == typeof e && (r ? e() : i.push(e))
            }, a.destroy = function() {
                u.destroy()
            };
            var l = {};
            a.handleEvent = function(e, n) {
                if (!e) throw new Error("Event name not specified");
                if ("function" != typeof n) throw new Error("Handler is not a function");
                l[e] || (l[e] = []), l[e].push(n), 1 === l[e].length && (u.bind(e, function(n, t) {
                    for (var o = l[e], r = 0; r < o.length; ++r) o[r](t)
                }), u.call({
                    method: "handleEvent",
                    params: [e, !0],
                    success: function() {},
                    error: c
                }))
            }, a.unregisterEventHandler = function(e, n) {
                if (!e) throw new Error("Event name not specified");
                var t = l[e];
                if (!t || !t.length) return void(window.console && window.console.log && console.log("Trying to unregister listener, but there are none for event: " + e));
                for (var o = [], r = 0; r < t.length; ++r) t[r] !== n && o.push(t[r]);
                l[e] = o, o.length || (u.unbind(e), u.call({
                    method: "handleEvent",
                    params: [e, !1],
                    success: function() {},
                    error: c
                }))
            }, a.postRequest = function(e, n, t) {
                u.call({
                    method: "postRequest",
                    params: [e, n],
                    success: function() {},
                    error: t || c
                })
            };
            var f, d = function(e) {
                a[e] = function(t, o, r) {
                    "getInfo" === e && (r = o, o = t, t = [n]), "function" == typeof t && (r = o, o = t, t = []), u.call({
                        method: e,
                        params: t,
                        success: o,
                        error: r || c
                    })
                }
            };
            a.isSupported = function(e, n) {
                "function" == typeof e && (n = e, e = null), "function" != typeof n && (n = function(e) {
                    a.log("Callback function for isSupported() not provided. Client supported: " + e)
                });
                var t = function(t) {
                    f = t;
                    var o = t.clientSupported;
                    e && (o = o && t.version === e), n(o)
                };
                if (f) t(f);
                else if ("function" == typeof a.getInfo) a.getInfo(t);
                else {
                    if (!r) throw new Error("Map not connected yet");
                    n(!1)
                }
            };
            var u = e.build({
                window: t.contentWindow,
                origin: o,
                scope: "Oskari",
                onReady: function() {
                    u.call({
                        method: "getSupportedFunctions",
                        success: function(e) {
                            for (var n in e) e.hasOwnProperty(n) && d(n);
                            r = !0;
                            for (var t = 0; t < i.length; ++t) i[t]()
                        },
                        error: function() {
                            throw new Error("Couldn't setup allowed functions")
                        }
                    })
                }
            });
            return a
        }
    }
});